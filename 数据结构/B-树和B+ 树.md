### B 树

#### 前言

了解B树是为了学习数据库索引调优的相关知识。因为数据库普遍采用B树或者B+树作为索引结构。

> B-树因为有个破折号所以经常有人误念为 “B减树”，其实不是，翻译说来其实就是“Balance Tree”，也就是平衡树。

B树的出现是为了弥补不同的存储级别之间的访问速度上的巨大差别，实现搞笑的I/O。

B树非常合适读取和写入相对较大的数据块的存储系统。它通常用于数据库和文件系统。

#### 定义

B树是一种平衡的多分数，通常我们说m阶的B树，它必须满足如下条件。

- 每个节点最多只有m个子节点；
- 每个非叶子节点（除了根）具有至少⌈ m/2⌉子节点，即⌈ m/2⌉<=M<=m；(M为子节点数量，m/2向上取整)
- 如果根不是叶节点，则根至少有两个子节点；
- 具有k个子节点的非叶子节点包含k -1个关键字；
- 所有叶子都出现在同一水平，没有任何信息（高度一致）
- 叶子节点的关键字符合⌈ m/2⌉-1<k<=m-1 (m/2向上取整)

> 注意子节点和关键字的区别，节点包含关键字，一个节点有多个关键字。

##### 什么是B树的阶？

B树中一个节点的子节点数目的最大值，用m表示，假如最大值为10，则为10阶，如图

![997909-20190727111522935-981534929](B-树和B+ 树.assets/997909-20190727111522935-981534929.png)

所有节点中，节点【13,16,19】拥有的子节点数目最多，四个子节点（灰色节点），所以可以定义上面的图片为4阶B树，现在懂什么是阶了吧

##### 什么是根节点？

节点【10】即为根节点，特征：根节点拥有的子节点数量的上限和内部节点相同，如果根节点不是树中唯一节点的话，至少有俩个子节点（不然就变成单支了）。在m阶B树中（根节点非树中唯一节点），那么有关系式2<= M <=m，M为子节点数量；包含的元素数量 1<= K <=m-1,K为元素数量。

##### 什么是内部节点？

节点【13,16,19】、节点【3,6】都为内部节点，特征：内部节点是除叶子节点和根节点之外的所有节点，拥有父节点和子节点。假定m阶B树的内部节点的子节点数量为M，则一定要符合（m/2）<=  M <=m关系式，包含元素数量M-1；包含的元素数量 （m/2）-1<= K <=m-1,K为元素数量。m/2向上取整。

##### 什么是叶子节点？

节点【1,2】、节点【11,12】等最后一层都为叶子节点，叶子节点对元素的数量有相同的限制，但是没有子节点，也没有指向子节点的指针。特征：在m阶B树中叶子节点的元素符合（m/2）-1<= K <=m-1。

#### 插入和删除

对于B树的插入和删除很有意思，可通过以下链接了解学习！

[B树和B+树的详解](https://www.cnblogs.com/lianzhilei/p/11250589.html)

### 磁盘IO与预读

计算机存储设备一般分为：内存储器和外存储器；内存储器就是内存，内存存取速度块，但容量小，也贵，不能长期保存数据（在不通电的情况下数据会消失）

考虑到磁盘IO是非常费时的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，还把相邻的数据也都读取到内存缓冲区，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。

重点1：不同容量的存储器，**访问速度**差异悬殊

- 磁盘(ms级别) << 内存(ns级别)， 100000倍
- 若内存访问需要1s，则一次外存访问需要一天
- 为了避免1次外存访问，宁愿访问内存100次...所以将最常用的数据存储在最快的存储器中

重点2： 从磁盘中读 1 B，与读写 1KB 的**时间成本**几乎一样

#### 总结

从以上数据中可以总结出一个道理，索引查询的数据主要受限于硬盘的I/O速度，查询I/O次数越少，速度越快，所以B树的结构才应需求而生；B树的每个节点的元素可以视为一次I/O读取，树的高度表示最多的I/O次数，在相同数量的总元素个数下，每个节点的元素个数越多，高度越低，查询所需的I/O次数越少；假设，一次硬盘一次I/O数据为8K，索引用int(4字节)类型数据建立，理论上一个节点最多可以为2000个元素，2000*2000*2000=8000000000，80亿条的数据只需3次I/O（理论值），可想而知，B树做为索引的查询效率有多高；

另外也可以看出同样的**总元素个数**，**查询效率**和**树的高度**密切相关

### B+树

#### B+树的特征

- 有m个子树的中间节点包含有m个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引；
- 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)；
- 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)；

#### B+树的优点

*1）B+树的磁盘读写代价更低*

　　B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了；

*2）B+树查询效率更加稳定*

　　由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；

*3）B+树便于范围查询（最重要的原因，范围查找是数据库的常态）*

　　B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低；不懂可以看看这篇解读-》范围查找

 

补充：B树的范围查找用的是中序遍历，而B+树用的是在链表上遍历；

![eba89b7fb850be843ed7b39396173bd4](B-树和B+ 树.assets/eba89b7fb850be843ed7b39396173bd4.png)
