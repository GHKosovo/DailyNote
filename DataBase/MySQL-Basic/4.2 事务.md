## 什么是事务？

一个事务是一个完整的业务逻辑单元，不可再分

### 例子

比如：银行账户转账，从A账户向B账户转账1000，需要执行两条update语句：

```
update t_act set balance = balance - 10000 where actno = 'act-001';
update t_act set balance = balance + 10000
where actno = 'act--002';
```

以上两条DML语句必须同时成功，或者同时失败，不允许出现一条成功，一条失败；

要想保证以上的两条DML语句同时成功或者同时失败，那么久需要使用数据库的事务机制；

和事务相关的语句只有：DML语句（delete insert update）,因为他们这三个语句都是和数据库当中的数据相关的，事务的存在就是为了保证数据的完整性和安全性。

### 事务的原理

假设一个事儿，需要实现执行一条insert,再执行一条update，最后执行一条delete，这个事儿才算完成；

```
开启事务机制（开始）

执行insert 语句--> insert ...(这个执行成功之后，把这个执行记录到数据库的操作历史当中，并不会向文件中保存一条数据，不会真正的修改硬盘上的数据。)

执行update语句--> update...(这个执行也是记录到历史操作，并不会真正的修改硬盘上的数据。)

执行delete语句--> delete...(这个执行也是记录到历史操作[记录到缓存]，并不会真正的修改硬盘上的数据。)

提交事务或者回滚事务（结束）
```

### 事务的特性

事务包括四大特性：ACID

原子性（A）:事务是最小的工作单元，不可再分。

一致性（C）：事务必须保证多条DML语句同时成功或者同时失败

隔离性（I）：事务A与事务B之间具有隔离

持久性（D）：持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的结束

### 事务的隔离性

事务隔离性存在格力级别，理论上隔离级别包括4个：

第一级别：读未提交（read uncommitted）

- 对方事务没还没有提交，我们当前事务可以读取到对方未提交的数据。
- 读未提交存在脏读（Dirty Read）现象：表示读到了脏的数据；

第二级别：读已提交（read committed）

- 对方事务提交之后的数据我方可以读取到。
- 这种隔离级别解决了脏读现象；但是存在问题：不可重复读；

第三级别：可重复读（repeatable read）

- 这个隔离级别解决了：不可重复读；但是存在读取到的数据是幻象

第四级别：序列化读、串行化读

​	解决了所有问题；但是效率低，需要事务排队

> oracle数据库默认的隔离级别是：读已提交
>
> mysql数据库默认的隔离级别是：可重复读

#### mysql事务默认情况下是自动提交的

什么是自动提交？只要执行任意一条DML语句则提交一次

怎么关闭自动提交？start transaction

也就是说使用事务可以让自动提交关闭，只有事务commit后才是真正的提交。

