## 关于Java语言当中的多态语法机制

1. 关于多态中涉及到的几个概念：

   - 向上转型（upcasting）

     - 子类型-->父类型
     - 又被称为：自动类型转换

   - 向下转型（downcasting）

     - 父类型-->子类型
     - 又被称为：强制类型转换【需要加强制类型转换符】

   - 需要记忆：

     无论是向上转型还是向下转型，两种类型之间必须要有继承关系。没有继承关系，程序无法编译通过的。

   - sxx

## Java程序永远都分为编译阶段和运行阶段

```java
Animal a2 = new Cat();
//move定义在Animal类中,Cat中可定义可不定义
a2.move();
//catchMouse定义在Cat类中，在Animal中没定义。
a2.catchMouse
```

1. 先分析编译阶段，在分析运行阶段，编译无法通过，根本是无法运行的。

2. 编译阶段编译器检查`a2`这个引用的数据类型为`Animal`，由于`Animal.class`字节码当中有`move()`方法，所以编译通过了。这个过程我们称为静态绑定，编译阶段绑定。只有静态绑定成功之后才有后续的运行。

3. 在程序运行阶段，`JVM`堆内存当中真实创建的对象是`Cat`对象，那么以下程序在运行阶段一定会调用`Cat`对象的`move()`方法，此时发生了程序的动态绑定，运行阶段绑定。

4. 无论是`Cat`类有没有重写`move`方法，运行阶段一定调用的是`Cat`对象的`move`方法，因为底层真实对象是`Cat`对象。

5. 父类型引用指向子类型对象这种机制导致程序存在编译阶段绑定和运行阶段绑定两种不同的形态/状态，这种机制可以成为一种多态语法机制。

6. 对于`a2.catchMouse`报错的原因，因为编译阶段编译器检查`a2`的类型是Animal类型，从`Animal.class`字节码文件当中查找`catchMouse()`方法，最终没有找到方法，导致静态绑定失败，没有绑定成功，也就是说编译失败了。后面也运行不了了。

   

```java
//父类型引用指向子类型对象【多态】
Animal a3 = new Bird();
Cat c3 = (Cat)a3;
```

1. 以上程序编译是没有问题的，因为编译器检查到`a3`的数据类型是`Animal`，`Animal`和`Cat`之间存在继承关系，并且`Animal`是父类型，`Cat`是子类型，父类型转换成子类型叫做向下转型，语法合格。

2. 程序虽然编译通过了，但是程序在运行阶段出现异常，因为`JVM`堆内存当中真是存在的对象是`Bird`类型，`Bird`对象无法转换成`Cat`对象，因为两种类型之间不存在任何继承关系，此时出现了著名的异常：

   - `java.lang.ClassCastException`
   - 类型转换异常，这种异常总是在“向下转型”的时候会发生

3. 以上异常只有在强制类型转换的时间会发生，也就是说`向下转型`存在隐患（编译过了，但是运行错了！）

4. 向上转型只要编译通过了，运行一定不会出问题：`Animal a = new Cat();`

5. 向下转型编译通过，运行可能错误：`Animal a3 = new Bird;Cat c3 = (Cat)a3;`

6. 怎么避免向下转型出现的`ClassCastException`呢？

   ​	使用`instanceof`运算符可以避免出现以上的异常。

7. `instanceof`运算符怎么用？

   1. 语法格式：引用  ` instanceof`  数据类型名
   2. 以上运算符的执行结果类型是布尔类型，结果可能是true/false
   3. 关于运算结果true/false
      - true表示： 这个引用指向的对象是这个数据类型
      - false表示：这个引用指向的对象不是这个数据类型

8. Java规范中要求：在进行强制类型转换之前，建议采用`instanceof`运算符进行判断，避免`ClassCastException`异常。

## 多态的作用是什么？

降低程序的耦合度，提高程序的扩展力。

能使用多态尽量使用多态。

父类型引用指向了类型对象。

```java
public void feed(Animal a){ //a是一个父类型的引用，传过来的都是Animal的子类。
    a.move
}

```

> 面向抽象编程，不要面向具体编程
>
> 面向抽象编程的好处是，耦合度低，扩展力强。

