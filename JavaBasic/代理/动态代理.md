## 什么是动态代理

使用jdk的反射机制，创建对象的能力，创建的是代理类的对象，而不用创建类文件。不用写java文件；

动态：在程序执行时，调用jdk提供的方法才能创建代理类的对象

## 动态代理的实现

1. jdk动态代理（理解）：使用java反射包中的类和接口实现动态代理的功能。

   反射包java.lang.reflect，里面有三个类：InvocationHandler,Method,Proxy;

2. cglib动态代理（了解）：cglib是第三方的工具类库，创建代理对象。cglib的原理是继承，cglib通过继承目标类，创建它的子类，在子类中重写父类中同名的方法，实现功能的修改。

   因为cglib是继承，需要重写方法，所以目标类不能是final的，方法也不能是final的，比如mybtis和spring框架中都有使用的

## JDK动态代理

反射，Method类。类中的方法，通过Method可以执行某个方法。

jdk动态代理的实现

反射包 java.lang.reflect,里面有三个类：InvocationHandler,Method,Proxy;

## InvocationHandler接口（调用处理器）

InvocationHandler接口就一个方法invoke();

invoke(): 表示代理对象要执行的功能代码。你的代理类要完成的功能就写在invoke()方法中

代理类完成的功能：

1. 调用目标方法，执行目标方法的功能
2. 功能增强，在目标方法调用时，增强功能；

**方法原型**：

参数：

- Object proxy:jdk创建的代理对象，无需赋值
- Method method:目标类中的方法，jdk提供method对象的
- Object[] args: 目标类中的方法的参数，jdk提供的

```
public Object invoke(Object proxy,Method method,Object[] args)
```

InvocationHandler 接口，表示你的代理要干什么

### 怎么用

1.创建类实现接口InvocationHandler

2.重写invoke()方法，把原来静态代理中代理类要完成的功能写在这里

## Method类

表示方法的，确切地说，就是目标类中的方法

作用：通过Method可以执行某个目标类的方法，Method.invoke();

例子：Object ret = method.invoke(target, "张三");

说明：Method.invoke()就是用来执行目标方法的，等同于静态代理中的：

```
//向厂家发送订单，告诉厂家，我买了U盘，厂家发货float price = factory.sell(amount); //厂家的价格
```

## Proxy类

核心的对象，创建代理对象，之前创建对象都是new 类的构造方法()

现在我们使用Proxy类的方法，代替new的使用

方法：静态方法：newProxyInstance()

作用是：创建代理对象，等同于静态代理中的`Tmall tmall = new Tmall();`

参数：

- ClassLoader loader 类加载器，负责向内存中加载对象的，使用反射获取对象的ClassLoader

  类a，a.getClass().getClassLoader()，目标对象的类加载器

- Class<?> interface: 接口，目标对象实现的接口，也是反射获取的

- InvocationHandler h :我们自己写的，代理类要完成的功能。

返回值：就是代理对象

```
public static Object newProxyInstances(ClassLoader loader, Class<?>[] interfaces,InvocationHandler h ) 
```

