1.垃圾回收是在内存中存在没有引用的对象或超过作用域的对象时进行。

2.垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。

3.System.gc()和Runtime.gc()这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。

4.finalize方法：垃圾回收器(garbage collector)决定回收某对象时，就会运行该对象的finalize()方法 但是在Java中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说filalize()可能永远不被执行，显然指望它做收尾工作是靠不住的。 那么finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。

5.如果对象的引用被置为null，垃圾回收期不会立即释放对象占用的内存，而是，在下一个垃圾回收周期中，这个对象将是可被回收的。

6.串行(serial)收集器和吞吐量(throughput)收集器的区别：吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。

7.java中，对象什么时候被回收？当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。