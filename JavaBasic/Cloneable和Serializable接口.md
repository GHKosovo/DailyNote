## Cloneable接口

**clone：**它允许在堆中克隆出一块和原对象一样的对象，并将这个对象的地址赋予新的引用。

Java 中一个类要实现clone功能 必须实现 Cloneable接口，否则在调用 clone() 时会报 CloneNotSupportedException 异常。

Java中所有类都默认继承java.lang.Object类，在java.lang.Object类中有一个方法clone()，这个方法将返回Object对象的一个拷贝。

#### 注意：

1. **拷贝对象返回的是一个新对象**，而不是一个引用；
2. 拷贝对象与用 new操作符返回的新对象的区别就是**这个拷贝已经包含了一些原来对象的信息**，而不是对象的初始信息。

如果一个类重写了 Object 内定义的 clone()方法 ，需要同时实现 Cloneable 接口（虽然这个接口内并没有定义 clone() 方法），否则会抛出异常，也就是说， Cloneable 接口只是个合法调用 clone() 的标识（marker-interface）。

## Seriallizable接口

Serializable接口中一个成员函数或者成员变量也没有，这个接口的作用就是实现序列化，那什么是序列化？

### 序列化

序列化：对象的寿命通常随着生成该对象的程序的终止而终止，而有时候需要把在内存中的各种对象的状态（也就是实例变量，不是方法）保存下来，并且可以在需要时再将对象恢复。 Java提供了一种保存对象状态的机制，那就是序列化。

Java 序列化技术可以将一个对象的状态写入一个Byte 流里（序列化），并且可以从其它地方把该Byte 流里的数据读出来（反序列化）。

### **什么时候需要序列化**

想把内存中的对象状态保存到一个文件中或者数据库中时候；
想把对象通过网络进行传播的时候

### **如何序列化**

只要一个类实现Serializable接口，那么这个类就可以序列化了。

**sserialVersionUID**

注意到上面程序中有一个 serialVersionUID ，实现了Serializable接口之后，Eclipse就会提示你增加一个 serialVersionUID，虽然不加的话上述程序依然能够正常运行。

序列化 ID 在 Eclipse 下提供了两种生成策略

一个是固定的 1L
一个是随机生成一个不重复的 long 类型数据（实际上是使用 JDK 工具，根据类名、接口名、成员方法及属性等来生成）

**serialVersionUID的作用是什么？**

当执行序列化的时候，会把对象写到磁盘中，会根据当前这个类的结构生成一个版本号ID，当反序列化的时候，程序会比较磁盘中的序列化版本号ID跟当前的类结构生成的版本号是否一致，如果一致则反序列化成功，否则失败。

加上版本号，有助于当我们的类结构发生变化，依然可以把之前已经序列化的对象反序列化成功。

**transient关键字**

经常在实现了 Serializable接口的类中能看见transient关键字。 transient关键字的作用是：阻止实例中那些用此关键字声明的变量持久化；当对象被反序列化时（从源文件读取字节序列进行重构），这样的实例变量值不会被持久化和恢复。

当某些变量不想被序列化，那么此时就需要用transient关键字来声明该变量。