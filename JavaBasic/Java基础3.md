## 面向对象的特征

有四个：抽象，继承，封装，多态

- 抽象就是把一些属性或者方法抽象到一个类中，后面继承该抽象类的实现类就可以使用这个抽象类的属性和方法，如果有多个该抽象类的实现类就可以少写很多相同的属性，然后在实现类中也可以再定义属性，或者方法，这样就可以让是实现类也具备自己的特性，得以区分，举个例子，比如图形，有三角形，四方形等到，他们都有一些共同的属性，使用抽象类来定义最好了；抽象方法也是类似的道理

- 继承包括extends和implements两种方法，我们通常使用 instanceof 操作符，来检验一个对象是另一个对象的一个分类/实例；对于extends方法，子类可以继承父类的除 private 属性外所有的属性；父类中的 private 成员在子类中是不可见的，因此在子类中不能直接使用它们；Java只允许单继承；

- 封装，可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制；一般就是通过getter/setter方法访问类中的私有变量；

- 多态是同一个行为具有多个不同表现形式或形态的能力。实例代码如下

```java
理解方法： 以Animal、Dog、Cat类为例，它们都有eat方法，如果使用以下代码：

Animal animal = new Dog();
animal.eat();
animal = new Cat();
animal.eat();

java执行流程：
java会先看Animal中是否有eat方法的定义：{
    如果没有则会报错；
    如果有则java会再看实例化对象的类中是否有eat方法的实现{
        如果没有则java会看Animal中是否有eat方法的实现{
            如果没有则会报错；
            如果有则会调用；
        }
        如果有则会调用实例化对象的类中的eat方法。
    }
}
```

<hr>

## 关于float和double类型的主要区别

可查看知乎上[网友的解释](https://www.zhihu.com/question/46432979/answer/221485161)

## JAVA的数据类型

Java支持的数据类型包括两种，一种是基本数据类型，一种是引用类型，也即是包装类；

**引用类型定义**，是指除了基本的基本类型之外的所有类型（如通过 class 定义的类型）

比如`String a`其实是对象的引用，JVM中虚拟栈中存的是对象的地址，创建的对象实质在堆中，通过地址来找到堆中的对象的过程，即为引用类型

| 基本数据类型 | 包装类        |
| ------------ | ------------- |
| **byte**     | **Byte**      |
| **short**    | **Short**     |
| **int**      | **Integer**   |
| **char**     | **Character** |
| **float**    | **Float**     |
| **double**   | **Double**    |
| **long**     | **Long**      |
| **boolean**  | **Boolean**   |

### JAVA基本数据类型和包装类相互转换

> 具体内容，访问[W3Cschool官网](https://www.w3cschool.cn/jeep711blog/jeep711blog-hj16252t.html)

1. 把基本数据类型 → 包装类：通过对应包装类的构造方法实现
2. 除了Character外，其他包装类都可以传入一个字符串参数构建包装类对象
3. 包装类 → 基本数据类型，包装类的实例方法xxxValue();    // xxx表示包装类对应的基本数据类型
4. **基本类型和String之间的转换** 
   - String → 基本类型，除了Character外所有的包装类提供parseXxx(String s)静态方法， 用于把一个特定的字符串转换成基本类型变量； 
   - 基本类型 → String，String 类有静态方法valueOf()，用于将基本类型的变量转换成String类型 

### JAVA自动装箱与自动拆箱

**什么是自动装箱**？：可把一个基本类型变量直接赋给对应的包装类对象或则Object对象

**什么是自动拆箱？**：允许把包装类对象直接赋给对应的基本数据类型 

<hr>

## 常识

### 接口和抽象类

**接口**没有实现，一般只写方法，而实现接口一般就是实现类了；----用于解耦合

**抽象**，其实就是父类，子类通过继承它来获得一些属性和方法，这样如果有多个子类的话，就可以少写很多方法和属性，直接从父类继承就可以了

接口所有的方法都是抽象的；类可以实现很多接口（其实也是继承一个接口而已，但是这个继承的接口可能继承了多个其他接口，故说他实现了多个接口），但只能继承一个抽象类；类如果不实现抽象类和接口方法，那它就只能是抽象类了；抽象可以不提供接口方法实现的情况下，实现接口；接口中的变量默认都是final类型；接口中的成员函数默认都是public；接口和实现都不可以被实例化。

### HashCode

hashCode 的常规协定是：  在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。  如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。  以下情况不 是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。

### 重写和重载

> 重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理
>
> 重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法

**重载**：发生在一个类里面，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。（混淆点：跟返回类型没关系）

> 以下不构成重载
> public double add(int a,int b)
> public int add(int a,int b)​
>
> 会报错！！！

**重写**：重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写；方法名相同，参数列表和返回值类型也相同

重写和重载的不同，重写跟继承有关，没有继承就没有重写；而重载其实就是定义一些同一方法名称，参数不同的方法

### 内存泄露

举个例子，比如说新建对象会占用堆空间，如果这个堆空间没用了，但是却没有销毁它，一直留着，日积月累，占用了许多堆空间，但是都是没用的，有朝一日堆内存爆了，这就是内存泄漏。